### 1、介绍

- `Java API`规范 (`JSR303`) 

  定义了`Bean`校验的标准`validation-api`，但没有提供实现。

- `hibernate validation`

  对这个规范的实现，并增加了校验注解如`@Email`、`@Length`等。

- `Spring Validation`

  对`hibernate validation`的二次封装，用于支持`spring mvc`参数自动校验。

### 2、使用

#### 2.1 引入依赖

```xml
<dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-validator</artifactId>
    <version>6.0.1.Final</version>
</dependency>

<!-- springBoot 中使用 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
    <scope>compile</scope>
</dependency>
```

#### 2.2 参数校验

- `requestBody`参数校验

  在`DTO`字段上声明约束注解，然后在方法参数上声明校验注解**，**使用`@Valid` 或者 `@Validated`

  如果校验失败，会抛出`MethodArgumentNotValidException`异常，`Spring`默认会将其转为`400（Bad Request）`请求。

- `requestParam/PathVariable`参数校验

  `GET`请求一般会使用`requestParam/PathVariable`传参。如果参数比较多 (比如超过 6 个)，还是推荐使用`DTO`对象接收。否则，推荐将一个个参数平铺到方法入参中。

  在这种情况下，**必须在`Controller`类上标注`@Validated`注解，并在入参上声明约束注解 (如`@Min`等)**。

  如果校验失败，会抛出`ConstraintViolationException`异常。

#### 2.3 统一异常处理

如果校验失败，会抛出`MethodArgumentNotValidException`或者`ConstraintViolationException`异常。在实际项目开发中，通常会用**统一异常处理**来返回一个更友好的提示。

```java
@RestControllerAdvice
public class CommonExceptionHandler {

    @ExceptionHandler({MethodArgumentNotValidException.class})
    @ResponseStatus(HttpStatus.OK)
    public Result handleMethodArgumentNotValidException(MethodArgumentNotValidException e) {
        BindingResult bindingResult = e.getBindingResult();
        StringBuilder sb = new StringBuilder("校验失败:");
        for (FieldError fieldError : bindingResult.getFieldErrors()) {
            sb.append(fieldError.getField()).append("：").append(fieldError.getDefaultMessage()).append(", ");
        }
        String msg = sb.toString();
       return Result.fail(BusinessCode.参数校验失败, msg);
    }

    @ExceptionHandler({ConstraintViolationException.class})
    @ResponseStatus(HttpStatus.OK)
    public Result handleConstraintViolationException(ConstraintViolationException ex) {
        return Result.fail(BusinessCode.参数校验失败, ex.getMessage());
    }
}
```

#### 2.4 注解

| 注解                               | 支持的 Java 类型                                             | 说明                                    |
| ---------------------------------- | ------------------------------------------------------------ | --------------------------------------- |
| @Null                              | Object                                                       | 为 null                                 |
| @NotNull                           | Object                                                       | 不能为 null                             |
| @NotBlank                          | CharSequence                                                 | 不为null，且必须有一个非空格字符        |
| @NotEmpty                          | CharSequence、Collection、Map、Array                         | 不为null，且不为空（length/size>0）     |
| @AssertTrue                        | boolean、Boolean                                             | 为 true （为null有效）                  |
| @AssertFalse                       | boolean、Boolean                                             | 为 false（为null有效）                  |
| @Future                            | Date、Calendar、Instant、LocalDate、LocalDateTime、LocalTime、MonthDay、OffsetDateTime、OffsetTime、Year、YearMonth、ZonedDateTime、HijrahDate、JapaneseDate、MinguoDate、ThaiBuddhistDate | 验证日期为当前时间之后（为null有效）    |
| @FutureOrPresent                   | 同 @Future                                                   | 验证日期为当前时间或之后（为null有效）  |
| @Past                              | 同 @Future                                                   | 验证日期为当前时间之前（为null有效）    |
| @PastOrPresent                     | 同 @Future                                                   | 验证日期为当前时间或之前（为null有效）  |
| @Max                               | BigDecimal、BigInteger，byte、short、int、long以及包装类     | 小于或等于（为null有效）                |
| @Min                               | 同上                                                         |                                         |
| @DecimalMax                        | BigDecimal、BigInteger、CharSequence，byte、short、int、long以及包装类 | 小于或等于（为null有效）                |
| @DecimalMin                        | 同上                                                         | 大于或等于（为null有效）                |
| @Negative                          | BigDecimal、BigInteger，byte、short、int、long、float、double以及包装类 | 负数（为null有效）                      |
| @NegativeOrZero                    | 同上                                                         | 负数或零（为null有效）                  |
| @Positive                          | 同上                                                         | 正数（为null有效）                      |
| @PositiveOrZero                    | 同上                                                         | 正数或零（为null有效）                  |
| @Digits(integer = 3, fraction = 2) | BigDecimal、BigInteger、CharSequence，byte、short、int、long以及包装类 | 整数位数和小数位数上限（为null有效）    |
| @Pattern                           | CharSequence                                                 | 匹配指定的正则表达式（为null有效）      |
| @Email                             | 邮箱地址                                                     | 邮箱地址（为null有效，默认正则 `'.*'`） |
| @Size                              | CharSequence、Collection、Map、Array                         | 大小范围（length/size>0）（为null有效） |
| @Length                            | String                                                       | 数值类型和String                        |
| @Range                             | 数值类型和String                                             | 指定范围                                |
| @URL                               |                                                              | URL地址验证                             |



### 3、进阶使用

#### 3.1 分组校验

多个方法需要使用同一个`DTO`类来接收参数，而不同方法的校验规则很可能是不一样的。这个时候，简单地在`DTO`类的字段上加约束注解无法解决这个问题。因此，`spring-validation`支持了**分组校验**的功能，专门用来解决这类问题。还是上面的例子，比如保存`User`的时候，`UserId`是可空的，但是更新`User`的时候，`UserId`的值必须`>=10000000000000000L`

- 创建一个包名字为 group 包，创建分组标识接口

  ```java
  /**
   * 参数校验分组-新增
   *
   * @author xiongxq
   */
  public interface Insert {
  
  }
  ```

  ```java
  /**
   * 参数校验分组-修改
   *
   * @author xiongxq
   */
  public interface Update {
  
  }
  ```

- 约束注解上声明适用的分组信息`groups`

  ```java
  @NotBlank(groups = {Update.class}, message = "主键[id]不能为空！")
  private String id;
  
  @NotBlank(groups = {Insert.class, Update.class}, message = "名称[name]不能为空！")
  private String name;
  ```

- **`@Validated`注解上指定校验分组**

  ```java
  @PostMapping("/add")
  public ResultBean insert(@Validated(Insert.class) @RequestBody ClinicDTO req) {
      Boolean res = clinicService.add(req);
      return ResultBean.success(res);
  }
  
  @PostMapping("/update")
  public ResultBean updateClinic(@Validated(Update.class) @RequestBody ClinicDTO req) {
      Boolean res = clinicService.updateClinic(req);
      return ResultBean.success(res);
  }
  ```

#### 3.2 嵌套校验

`DTO`类里面的某个字段也有可能是一个对象，这种情况下，可以使用`嵌套校验`对该字段进行校验，此时`DTO`类的对应字段必须标记`@Valid`注解。

#### 3.3 集合校验

如果请求体直接传递了`json`数组给后台，并希望对数组中的每一项都进行参数校验。此时，如果我们直接使用`java.util.Collection`下的`list`或者`set`来接收数据，参数校验并不会生效！我们可以使用自定义`list`集合来接收参数：

- **包装`List`类型，并声明`@Valid`注解**

  ```java
  public class ValidationList<E> implements List<E> {
  
      @Delegate
      @Valid
      public List<E> list = new ArrayList<>();
  
      @Override
      public String toString() {
          return list.toString();
      }
  }
  ```

#### 3.4 自定义校验

- **自定义约束注解**

  ```java
  package com.jusekj.his.web.manage;
  
  import javax.validation.Constraint;
  import javax.validation.Payload;
  import java.lang.annotation.Documented;
  import java.lang.annotation.Repeatable;
  import java.lang.annotation.Retention;
  import java.lang.annotation.Target;
  
  import static java.lang.annotation.ElementType.*;
  import static java.lang.annotation.RetentionPolicy.RUNTIME;
  
  /**
   * @author xiongxq
   */
  @Documented
  @Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE})
  @Constraint(validatedBy = {MobileValidator.class})
  @Retention(RUNTIME)
  @Repeatable(Mobile.List.class)
  public @interface Mobile {
  
      /**
       * 错误提示信息，可以写死,也可以填写国际化的key
       */
      String message() default "手机号码不正确";
  
      Class<?>[] groups() default {};
  
      Class<? extends Payload>[] payload() default {};
  
      String regexp() default "^1([38][0-9]|4[579]|5[0-3,5-9]|6[6]|7[0135678]|9[89])\\d{8}$";
  
      @Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE})
      @Retention(RUNTIME)
      @Documented
      @interface List {
          Mobile[] value();
      }
  }
  ```
  
  `message` ：错误提示信息，可以写死,也可以填写国际化的key
  
  `groups` ：分组信息，允许指定此约束所属的验证组（下面会说到分组约束）
  
  `payload` ：有效负载，可以通过payload来标记一些需要特殊处理的操作
  
  @Repeatable 注解和List定义：可以让该注解在同一个位置重复多次，通常是不同的配置（比如不同的分组和消息）

- 实现`ConstraintValidator`接口编写约束校验器

  ```java
  package com.jusekj.his.web.manage;
  
  import javax.validation.ConstraintValidator;
  import javax.validation.ConstraintValidatorContext;
  import java.util.regex.Pattern;
  
  /**
   * @author xiongxq
   */
  public class MobileValidator implements ConstraintValidator<Mobile, String> {
  
      /**
       * 手机验证规则
       */
      private Pattern pattern;
  
      @Override
      public void initialize(Mobile mobile) {
          pattern = Pattern.compile(mobile.regexp());
      }
  
      @Override
      public boolean isValid(String value, ConstraintValidatorContext context) {
          if (value == null) {
              return true;
          }
          return pattern.matcher(value).matches();
      }
  }
  ```

  `ConstraintValidator`接口：定义了在实现中设置的两个类型参数，第一个指定要验证的注解类（如`Mobile`），第二个指定验证器可以处理的元素类型（如`String`）；

  `initialize()`方法：可以访问、约束注解的属性值；
  
  `isValid()`方法用于验证，返回true表示验证通过；Bean验证规范建议将空值视为有效。如果`null`不是元素的有效值，则应使用`@NotNull` 显式注释

#### 3.5 编程式校验



#### 3.6 快速失败



#### 3.7 @Valid 和 @Validated 的区别

| 区别         | @Valid                                          | @Validated              |
| ------------ | ----------------------------------------------- | ----------------------- |
| 提供者       | JSR-303 规范                                    | Spring                  |
| 标注位置     | METHOD, FIELD, CONSTRUCTOR, PARAMETER, TYPE_USE | TYPE, METHOD, PARAMETER |
| 是否支持分组 | 不支持                                          | 支持                    |
| 嵌套校验     | 支持                                            | 不支持                  |



### 4、实现原理

















