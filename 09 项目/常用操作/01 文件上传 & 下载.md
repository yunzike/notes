```react
fetch('api/zhxg-yxxt' + '/tjcx/xsxxcx/exportXsxxPDF', {
    method: 'post',
    headers: {
        'Content-Type': 'application/json'
    },
    body: JSON.stringify(xsids)
}).then(response => response.blob())
    .then(data => {
    let timestamp = new Date().getTime();
    const fileName = '学生信息' + timestamp + '.zip';
    if ('download' in document.createElement('a')) { // 非IE下载    
        const elink = document.createElement('a');
        elink.download = fileName;
        elink.style.display = 'none';
        elink.href = URL.createObjectURL(data);
        document.body.appendChild(elink);
        elink.click();
        URL.revokeObjectURL(elink.href) // 释放URL 对象    
        document.body.removeChild(elink)
    } else { // IE10+下载    
        navigator.msSaveBlob(data, fileName)
    }
})
```

```javascript
//发送axios请求
      axios({
        url: "http://localhost:8090/drugCenter/export",
        method: "get",
        responseType: "blob",
      }).then((res) => {
        let blob = new Blob([res.data], { type: "application/xlsx" });
        let url = window.URL.createObjectURL(blob);
        const link = document.createElement("a"); // 创建a标签
          link.style.display = "none";
        link.href = url;
        link.download = "download.xlsx"; // 重命名文件
        link.click();
        URL.revokeObjectURL(url);
      });
```

### 默认图片

```java
@ApiOperation("默认图片")
    @GetMapping("/default")
    public void defaultImage(HttpServletResponse response) {
        //使用字节流读取本地图片
        ServletOutputStream out = null;
        BufferedInputStream buf = null;
        //创建一个文件对象，对应的文件就是python把词云图片生成后的路径以及对应的文件名
        File file = new File("D:\\IdeaProjects\\ih-merchant\\merchant-web\\src\\main\\resources\\image\\default.jpg");
        try {
            //使用输入读取缓冲流读取一个文件输入流
            buf = new BufferedInputStream(new FileInputStream(file));
            //利用response获取一个字节流输出对象
            out = response.getOutputStream();
            //定义个数组，由于读取缓冲流中的内容
            byte[] buffer = new byte[1024];
            //while循环一直读取缓冲流中的内容到输出的对象中
            while (buf.read(buffer) != -1) {
                out.write(buffer);
            }
            //写出到请求的地方
            out.flush();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (buf != null) {
                try {
                    buf.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (out != null) {
                try {
                    out.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

    }
```

