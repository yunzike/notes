##  一、 线程安全问题

产生原因： 
1、多个线程操作共享数据。 
2、操作共享数据的线程代码有多条。 
当一个线程在执行操作共享数据的多条代码过程中，其他线程参与了运算。  

解决思路： 
将多条操作共享数据的线程代码封装起来，当有线程在执行这些代码的时候，其他线程不可以参与运算。必须要当前线程把这些代码都执行完毕后，其他线程才可以参与运算。即锁机制。  

### 2. 多线程加锁机制（两种）：

#### synchronized锁

synchronized（同步）是Java的一个关键字，它可以将代码块（方法）锁起来。

- synchronized是一种互斥锁。一次能允许一个线程进入被锁住的代码块

- synchronized是一种内置锁/监视器锁。Java中每个对象都有一个内置锁（监视器，也可以理解成锁标记），而synchronized就是使用对象的内置锁（监视器）来将代码块（方法）锁定的。

同步的前提：必须有多个线程并使用同一个锁。  

作用：

synchronized保证了线程的原子性。（被保护的代码是一次被执行的，没有任何线程会同时访问）；

synchronized保证了可见性。（当执行完synchronized之后，修改后的变量对其他线程可见

使用方法：

```java
//修饰普通方法
public class ThreadDemo{
    //此时使用的锁是ThreadDemo对象（内置锁）
    public synchronized void test(){
         ......
    }
}

//修饰代码块
public class ThreadDemo{
    private Object object = new Object();
    
    public void test(){
        //使用ThreadDemo对象（内置锁）作为锁
        synchronized(this){
            ......
        }
        
        //使用别的对象（object）作为锁（任何对象都有对应的锁标记）,称为客户端锁，不建议使用
        synchronized(object){
            ......
        }        
    }    
}

//修饰静态方法
public class ThreadDemo{
    //静态方法属于类方法，此时获取到的锁是属于类的锁(类的字节码文件对象)
    public synchronized static void test(){
        ......
    }
}
```

- 重入锁

  当线程A进入子类的doSomething（）方法时，已经拿到了子类实例对象的锁，随后在方法内又调用了父类的doSomething（）方法，同样被加锁，由于它拥有子类实例对象的锁还没有释放，是可以直接开锁进入父类doSomething（）方法的。这就是内置锁的可重用性。

  ```java
  public class Widget{
      ......
      //父类加锁方法
      public synchronized void doSomething(){
          ......
      }
  }
  
  public class LoggingWidget extends Widget{
      ......
      //子类加锁方法
      public synchronized void doSomething(){
          ......
          //调用父类加锁方法
          super.doSomething();
      }
  }
  ```

- 释放锁的时机

  1、当方法（代码块）执行完毕后会自动释放锁；

  2、当一个线程执行的代码出现异常时，其所持有的锁会自动释放。



#### Lock显式锁

- Lock方式来获取锁支持中断、超时不获取、是非阻塞的

- 提高了语义化，哪里加锁哪里解锁都得写出来

- 灵活性更好，但必须手动释放锁

- 支持Condition条件对象

- 允许多个读线程同时访问共享资源

##### 公平锁与非公平锁

公平锁：线程按照它们发出请求的顺序来获取锁

非公平锁：线程发出请求时可以插队获取锁

synchronized和Lock都是默认使用非公平锁的。如果不是必要情况下，不要使用公平锁，使用公平锁会带来一些性能的消耗。






















