#### 1. 线程相关介绍

- 进程与线程

  进程是程序的一次执行，是一个程序及其数据在处理机上顺序执行时所发生的的活动。进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。每个进程都有它自己的内存空间和系统资源。
  
- **多进程与多线程的区别**

  本质区别在于每个进程拥有自己的一整套变量，而线程则共享数据。共享变量使线程之间通信更有效、更容易。

- 引入线程的原因  

  注意：多线程的存在，不是提高程序的执行速度。其实**是为了提高应用程序的使用率**，程序的执行其实都是在**抢CPU的资源**，CPU的执行权。多个进程是在抢这个资源，**而其中的某一个进程如果执行路径比较多**，就会有**更高的几率**抢到CPU的执行权

- 并行与并发

  并行是多个处理器同一时刻内处理多个任务。而并发是一个处理器同一时间间隔内处理多个任务。

#### 2. 线程状态

- New(新创建)：new创建的新线程，还没有开始运行

- Runnable(可运行)：调用start方法之后，可能正在运行也可能没有运行

  抢占式调度：操作系统给每一个可运行线程一个时间片来执行任务。当时间片用完，操作系统剥夺该线程的运行权，根据优先级给另一个线程运行机会。

  协作式调度：手机等小型设备可能使用，一个线程只有在调用yield方法、或者被阻塞或等待时，线程才失去控制权。

- Blocked(被阻塞)：线程视图获取一个内部的对象锁，而该锁被其他线程持有，则该线程进入阻塞状态。

- Waiting(等待)：线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。

- Timed waiting(计时等待)：线程调用带有超时参数的方法（Thread.sleep、Object.wait、Thread.join、Lock.tryLock以及Condition.awaitde的计时版），进入计时等待。

- Terminated(被终止)：run方法正常退出而自然死亡或因没有捕获的异常终止了run方法而意外死亡。

#### 3. 线程属性

- 线程优先级

- 守护线程

- 线程组

- 处理未捕获异常的处理器

竞争条件

锁对象

条件对象



#### 4. 线程的创建

- 继承Thread，重写run方法

  ```java
  public class MyThread extends Thread {
      @Override
      public void run() {
          for (int i = 0; i < 200; i++) {
              System.out.println(i);
              try {
                  Thread.sleep(1);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          }
      }
  }
  
  public class TestThread {
      public static void main(String[] args) {
          MyThread t1 = new MyThread();
          MyThread t2 = new MyThread();
          
          t1.start();
          t2.start();
      }
  }
  ```

- 实现Runnable接口，重写run方法（推荐使用）  
  优点：  
  1、将线程要执行的任务从Thread的子类中分离出来，进行了单独封装。按照面向对象的思想将任务封装成对象。  
  2、避免了Java单继承的局限性。

  ```java
  public class MyThread implements Runnable {
      @Override
      public void run() {
          for (int i = 0; i < 200; i++) {
              System.out.println(i);
              try {
                  Thread.sleep(1);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          }
      }
  }
  
  public class TestThread {
      public static void main(String[] args) {

          MyThread thread = new MyThread();
          Thread t1 = new Thread(thread);
          Thread t2 = new Thread(thread);
  
          t1.start();
          t2.start();
      }
  }
  ```

run（）和start（）方法的区别：

- run（）用来封装被线程执行的代码，直接调用是普通方法。

- strart（）启动线程，再由jvm去调用该线程的run（）方法。

JVM启动默认是多线程的，除了主线程（main），至少还有垃圾回收线程（gcc）。








