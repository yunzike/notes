## 一、概述

- 程序(programm)

  是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码。

- 进程(process)与线程(thread)

  进程是程序的一次执行，是一个程序及其数据在处理机上顺序执行时所发生的的活动。进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。每个进程都有它自己的内存空间和系统资源。

- **多进程与多线程的区别**

  本质区别在于每个进程拥有自己的一整套变量，而线程则共享数据。共享变量使线程之间通信更有效、更容易。

- 引入线程的原因  

  注意：多线程的存在，不是提高程序的执行速度。其实**是为了提高应用程序的使用率**，程序的执行其实都是在**抢CPU的资源**，CPU的执行权。多个进程是在抢这个资源，**而其中的某一个进程如果执行路径比较多**，就会有**更高的几率**抢到CPU的执行权

- 并行与并发

  并行是多个处理器同一时刻内处理多个任务。而并发是一个处理器同一时间间隔内处理多个任务。

## 二、线程的创建

- 方式一：继承Thread，重写run方法

  ```java
  public class MyThread extends Thread {
      @Override
      public void run() {
          for (int i = 0; i < 200; i++) {
              System.out.println(i);
              try {
                  Thread.sleep(1);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          }
      }
  }
  
  public class TestThread {
      public static void main(String[] args) {
          MyThread t1 = new MyThread();
          MyThread t2 = new MyThread();
          
          t1.start();
          t2.start();
      }
  }
  
  //匿名子类
  
  ```

- 方式二：实现Runnable接口，重写run方法（推荐使用） 
  优点： 
  1、将线程要执行的任务从Thread的子类中分离出来，进行了单独封装。按照面向对象的思想将任务封装成对象。 
  2、避免了Java单继承的局限性。
  
  ```java
  public class MyThread implements Runnable {
        @Override
        public void run() {
            for (int i = 0; i < 200; i++) {
                System.out.println(i);
                try {
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    
    public class TestThread {
        public static void main(String[] args) {
    
            MyThread thread = new MyThread();
            Thread t1 = new Thread(thread);
            Thread t2 = new Thread(thread);
    
            t1.start();
            t2.start();
        }
    }
  ```
- 方式三：实现Callable接口

  实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大
  * 1. call()可以返回值的。
  * 2. call()可以抛出异常，被外面的操作捕获，获取异常的信息
  * 3. Callable是支持泛型的

  ```java
  /**
  * 
   * JDK 5.0新增
   */
  
  //1.创建一个实现Callable的实现类
  class NumThread implements Callable{
      //2.实现call方法，将此线程需要执行的操作声明在call()中
      @Override
      public Object call() throws Exception {
          int sum = 0;
          for (int i = 1; i <= 100; i++) {
              if(i % 2 == 0){
                  System.out.println(i);
                  sum += i;
              }
          }
          return sum;
      }
  }
  
  
  public class ThreadNew {
      public static void main(String[] args) {
          //3.创建Callable接口实现类的对象
          NumThread numThread = new NumThread();
          //4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象
          FutureTask futureTask = new FutureTask(numThread);
          //5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()
          new Thread(futureTask).start();
  
          try {
              //6.获取Callable中call方法的返回值
              //get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。
              Object sum = futureTask.get();
              System.out.println("总和为：" + sum);
          } catch (InterruptedException e) {
              e.printStackTrace();
          } catch (ExecutionException e) {
              e.printStackTrace();
          }
      }
  
  }
  ```

- 方式四：使用线程池

  好处：
* 1.提高响应速度（减少了创建新线程的时间）
  * 2.降低资源消耗（重复利用线程池中线程，不需要每次都创建）
  * 3.便于线程管理
  *      corePoolSize：核心池的大小
  *      maximumPoolSize：最大线程数
  *      keepAliveTime：线程没任务时最多保持多长时间后会终止
  
  ```java
  class NumberThread implements Runnable{
  
      @Override
      public void run() {
          for(int i = 0;i <= 100;i++){
              if(i % 2 == 0){
                  System.out.println(Thread.currentThread().getName() + ": " + i);
              }
          }
      }
  }
  
  class NumberThread1 implements Runnable{
  
      @Override
      public void run() {
          for(int i = 0;i <= 100;i++){
              if(i % 2 != 0){
                  System.out.println(Thread.currentThread().getName() + ": " + i);
              }
          }
      }
  }
  
  public class ThreadPool {
  
      public static void main(String[] args) {
          //1. 提供指定线程数量的线程池
          ExecutorService service = Executors.newFixedThreadPool(10);
          ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;
          //设置线程池的属性
  //        System.out.println(service.getClass());
  //        service1.setCorePoolSize(15);
  //        service1.setKeepAliveTime();
  
  
          //2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象
          service.execute(new NumberThread());//适合适用于Runnable
          service.execute(new NumberThread1());//适合适用于Runnable
  
  //        service.submit(Callable callable);//适合使用于Callable
          //3.关闭连接池
          service.shutdown();
      }
  
  }
  ```
  
- run（）方法和start（）方法的区别：

  run（）用来封装被线程执行的代码，直接调用是普通方法。

  strart（）启动线程，再由jvm去调用该线程的run（）方法。

【注意】JVM启动默认是多线程的，除了主线程（main），至少还有垃圾回收线程。

## 三、线程的状态

- New(新创建)：new创建的新线程，还没有开始运行

- Runnable(可运行)：调用start方法之后，可能正在运行也可能没有运行

  抢占式调度：操作系统给每一个可运行线程一个时间片来执行任务。当时间片用完，操作系统剥夺该线程的运行权，根据优先级给另一个线程运行机会。

  协作式调度：手机等小型设备可能使用，一个线程只有在调用yield方法、或者被阻塞或等待时，线程才失去控制权。

- Blocked(被阻塞)：线程视图获取一个内部的对象锁，而该锁被其他线程持有，则该线程进入阻塞状态。

- Waiting(等待)：线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。

- Timed waiting(计时等待)：线程调用带有超时参数的方法（Thread.sleep、Object.wait、Thread.join、Lock.tryLock以及Condition.awaitde的计时版），进入计时等待。

- Terminated(被终止)：run方法正常退出而自然死亡或因没有捕获的异常终止了run方法而意外死亡。

## 四、线程的属性

- 线程优先级

- 守护线程

- 线程组

- 处理未捕获异常的处理器

竞争条件

锁对象

条件对象
