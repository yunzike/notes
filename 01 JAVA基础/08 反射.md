### 反射

一般操作数据的时候，我们都是知道并且依赖数据类型的，如：根据类型使用 `new` 创建对象、根据类型定义变量。而反射，它是在运行时，而非编译时，动态的获取类型的信息，比如接口信息、成员信息、方法信息、构造方法信息等，根据这些动态获取到的信息创建对象、访问 / 修改成员、调用方法等。

反射就是加载类，并解剖出类的各个组成部分。

### Class 类

每个已经加载的类在内存中都有一份类信息，每个对象都有指向它所属类信息的引用。Java 中，类信息对应的类就是 java.lang.Class，Class是一个范型类。

#### 加载类(获取类的字节码到内存) 

```java
//方法一：使用 Object 类提供的 getClass 方法
Class clazz  = new Person().getClass();
//方法二：类名.class;
Class clazz  = Person.class;
//方法三：Class 的静态方法，类名为完整名称，带包名不带.java后缀
//可能抛出 ClassNotFoundException
Class clazz  = Class.forName("类名"); 
```

① 接口和枚举都有 Class 对象

```java
Class<Comparable> comparableClass = Comparable.class;
//CrmCommError 为枚举类
Class<CrmCommError> crmCommErrorClass = CrmCommError.class;
```

② 基本类型没有 `getClass` 方法，但也都有对应的 Class 对象，类型参数为对应的包装类型

``` java
Class<Integer> integerClass = int.class;
Class<Integer> integerClass1 = Integer.class;
Class<Long> longClass = long.class;
Class<Long> longClass1 = Long.class;
```

③ 对于数组，每种类型都有对应数组类型的 Class 对象，每个维度都有一个，即一维数组有一个，二维数组有一个不同的类型。

```java
String[] strs = {"111","222"};
Class<? extends String[]> strClass = strs.getClass();

int[] a = {1, 2, 3};
Class<? extends int[]> aClass = a.getClass();

int[][] b = new int[2][3];
Class<? extends int[][]> bClass = b.getClass();
```

④ void作为特殊返回类型，也有对应的 Class 。

```java
Class<Void> voidClass = void.class;
```

#### 常用方法

- 名称信息

  ```java
  String getName();		    		//返回 Java 内部使用的真正名称
  String getSimpleName();			//返回不带包信息的名称
  String getCanonicalName();	//返回更友好的名称
  String getPackage();				//返回包信息
  ```

  | Calss 对象        | getName               | getSimpleName | getCanonicalName      | getPackage  |
  | ----------------- | --------------------- | ------------- | --------------------- | ----------- |
  | `int.class`       | `int`                 | `int`         | `int`                 | `null`      |
  | `int[].class`     | `[I`                  | `int[]`       | `int[]`               | `null`      |
  | `int[][].class`   | `[[I`                 | `int[][]`     | `int[][]`             | `null`      |
  | `String.class`    | `java.lang.String`    | `String`      | `java.lang.String`    | `java.lang` |
  | `String[].class`  | `[Ljava.lang.String;` | `String[]`    | `java.lang.String[]`  | `null`      |
  | `HashMap.class`   | `java.util.HashMap`   | `HashMap`     | `java.util.HashMap`   | `java.util` |
  | `Map.Entry.class` | `java.util.Map$Entry` | `Entry`       | `java.util.Map.Entry` | `java.util` |

  其中`getName`返回值，使用前缀 `[ `表示数组，有几个 `[ ` 表示几维数组，数组类型用一个字符表示，`I` 表示 `int` ，`L` 表示类或接口，其他对应关系为：boolean（ Z ）、byte （ B ）、char （ C ）、double （ D ）、float （ F ）、long （ J ）、short（ S ）。对于引用类型，最后还有一个分号。

- 字段信息

  ```java
  Field[] getFields();							//返回所有的 public 字段，包括其父类的
  Field[] getField(String name);		//返回本类或父类中指定名称的 public 字段，找不到则抛出 NoSuchFieldException
  Field[] getDeclaredFields();					//返回本类声明的所有字段，包括非 public 的，但不包括父类的
  Field[] getDeclaredField(String name);//返回本类声明的指定名称的字段，找不到则抛出 NoSuchFieldException
  ```

  获取到的字段信息为 `Field` 类，位于包 `java.lang.reflect` 下，反射相关的类都位于该包下面。

  ```java
  /**
   * Field 类常用方法
   */
  
  String getName();										//获取字段的名称
  boolean isAccessible();							//判断当前程序是否有该字段的访问权限
  void setAccessible(boolean flag);		//flag 设置为 true 表示忽略 Java 的访问检查机制，以允许读写非 pbulic 字段
  Object get(Object obj);							//获取指定对象 obj 中该字段的值
  void set(Object obj, Object value);	//将指定对象 obj 中该字段的值设置为 value
  
  int getModifiers();						//返回字段的修饰符，值为一个 int 类型，需要使用 Modifier 类的静态方法进行解读
  Class<?> getType();						//返回字段的类型
  
  //其他基本类型字段操作
  
  ```

  对于静态变量，使用 `get/set` 方法，obj 会被忽略，可以直接传入 `null` ；

  对 `private` 字段，直接调用 `get/set` 方法会抛出非法访问异常 IllegalAccessException ，应该先调用 `setAccessible（true）` 以关闭 Java 的检查机制。

- 方法信息

  ```java
  //返回所有的 public 方法，包括其父类的
  Method[] getMethods();
  //返回本类或父类中指定名称和参数类型的 public 方法
  Method getMethod(String name, Class<?>... parameterTypes);
  //返回本类声明的所有方法，包括非 public 的，但不包括父类的
  Method[] getDeclaredMethods();
  //返回本类声明的指定名称和参数类型的方法，找不到则抛出 NoSuchMethodException
  Method getDeclaredMethod(String name, Class<?>... parameterTypes);
  ```

  获取到的方法信息为 `Method` 类，同样位于包 `java.lang.reflect` 下。

  ```java
  /**
   * Method 类常用方法
   */
  
  
  ```

  

  

- 创建对象和构造方法

  

- 类型检查和转换

  

- Class 的类型信息

  











### 内省（Introspector）

#### 概述

用来操作JavaBean的属性，也可以通过反射之后来操作。一般只用于框架中。  

JavaBean(实体类)：私有字段，并提供get和set方法作为借口。 
JavaBean的属性：实体类中get或set操作的内容。  

```java
public class Person {
	private String name;
	private int age;
	private String sex;
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	public String getSex() {
		return sex;
	}
	public void setSex(String sex) {
		this.sex = sex;
	}	
}
```

#### 使用方法：  

```java
@Test//获取JavaBean的所有属性
public void test1() throws IntrospectionException {
	BeanInfo info = Introspector.getBeanInfo(Person.class, Object.class);//内省获取BeanInfo，去除从Object继承的Class属性
	PropertyDescriptor[] descriptors = info.getPropertyDescriptors();//获取属性描述器
	for(PropertyDescriptor des:descriptors) {//打印所有属性名
		System.out.println(des.getName());
	}
}
	
@Test//操作JavaBean的某个属性
public void test2() throws Exception{
	Person p = new Person();
	PropertyDescriptor des = new PropertyDescriptor("age", Person.class);//获取JavaBean的某个属性
	Method writemethod = des.getWriteMethod(); //获取属性的写方法
	writemethod.invoke(p, 18);//执行写方法
	Method readmethod = des.getReadMethod();//获取属性的读方法
	System.out.println(readmethod.invoke(p));//执行读方法
System.out.println(des.getPropertyType());//获取属性需要的参数类型
}
```

BeanUtils:apache开发的专门用来操作JavaBean的框架 
配置：导入BeanUtils的jar包和它的支持jar包logging（可直接搜索后在apache官方下载） 
使用：  

```java
@Test
public void test1() throws Exception {
	Person p = new Person();
	BeanUtils.setProperty(p, "age", 18);//通过BeanUtils来操作Person的age属性
	System.out.println(BeanUtils.getProperty(p, "age"));
}

@Test
public void test2() throws Exception {
	String name = "aaa";
	String age = "18";
	String sex = "男";
		
	Person p = new Person();
	BeanUtils.setProperty(p, "name", name);
	BeanUtils.setProperty(p, "age", age);//可以直接传入String，BeanUtils会自动转成对应的参数类型，只支持8中基本数据类型
	BeanUtils.setProperty(p, "sex", sex);
	System.out.println(p.getName());
	System.out.println(p.getAge());
	System.out.println(p.getSex());
}
```

无法自动转换的（如Date类型），则可以通过注册转换器  