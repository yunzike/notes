### 一、序列化的含义、意义及使用场景

- 序列化

  将对象写入 IO 流中

- 反序列化

  从 IO 流中恢复对象

- 意义：

  序列化机制允许将实现序列化的 Java 对象转换为字节序列，这些字节序列可以保存在磁盘上，或者通过网络传输，以达到以后恢复成原来的对象。序列化机制使得对象可以脱离程序的运行而独立存在。

- 使用场景：

  所有可在网络上传输的对象都必须是可序列化得，比如 RMI（remote method invoke，即远程方法调用），传入的参数或返回的对象都是可序列化的，否则会出错；所有需要保存到磁盘的 Java 对象都必须是可序列化的。通常建议：程序创建的每个 JavaBean 都实现 Serializable 接口。

### 二、序列化的实现方式

实现 Serializable 接口或者 Externalizable 接口之一。

#### 1、Serializable

- 普通序列化

  Serializable 接口是一个标记接口，不用实现任何方法。一旦实现了此接口，该类的对象就是可序列化的。

  **反序列化不会调用构造方法。**反序列化的对象是由 JVM 自己生成的对象，不通过构造方法生成。

- 成员是引用的序列化

  如果一个可序列化的类的成员不是基本类型，也不是 String 类型，那这个引用类型也必须是可序列化的；否则，会导致此类不能序列化。

- 同一对象序列化多次的机制

  Java 序列化同一对象，并不会将此对象序列化多次得到多个对象。

  **Java 序列化算法：**

  ① 所有保存到磁盘的对象都有一个序列化的编码号

  ② 当程序试图序列化一个对象时，会先检查此对象是否已经序列化过，只有此对象从未（在此虚拟机）被序列化过，才会将此对象序列化为字节序列输出。

  ③ 如果此对象已经序列化过，则直接输出编号即可。

  **Java 序列化算法潜在的问题：**

  如果序列化一个可变对象（对象的内容可更改）后，更改了对象，再次序列化，并不会再次将此对象转换为字节序列，而只是保存序列化编号。

- 可选的自定义序列化

  对于某些不需要序列化的属性，可以使用 `transient` 关键字来修饰。反序列化出的对象，被 `transient`  修饰的属性是默认值。

  Java 提供了可选的自定义序列化，可以进行控制序列化的方式，或者对序列化数据进行编码加密等。

  ```java
  
  ```

#### 2、Externalizable：强制自定义序列化

通过实现 Externalizable 接口，必须实现 writeExternal、readExterNal 方法。还必须提供 public 的无参构造器，因为反序列化的时候需要反射创建对象。这种方法相对性能略好，但复杂度也提高了，一般通过实现 Serializable 接口。



### 三、序列化版本号 serialVersionUID

反序列化必须拥有 class 文件，但随着项目升级，class 文件也会升级，序列化怎么保证升级前后的兼容性呢？

Java 序列化提供了一个 `private static final long serialVersionUID` 的序列化版本号，只要版本号相同，即使更改了序列化属性，对象也可以正确被反序列化回来。

```java
public class Person implements Serializable {
    //序列化版本号
    private static final long serialVersionUID = 1111013L;
    private String name;
    private int age;
    //省略构造方法及get,set
}
```

如果反序列化使用的 class 的版本号与序列化时使用的不一致，反序列化会报 InvalidClassException 异常。

**序列化版本号可自由指定，如果不指定，JVM 会根据类信息自己计算一个版本号，这样随着 class 的升级就无法正确反序列化；不指定版本号另一个隐患是，不利于 jvm 间的移植，可能 class 文件没有更改，但不同 jvm 可能计算的规则不一样，这样也会导致无法序列化。**

什么情况下需要修改serialVersionUID呢？分三种情况。

- 如果只是修改了方法，反序列化不容影响，则无需修改版本号；
- 如果只是修改了静态变量，瞬态变量（transient修饰的变量），反序列化不受影响，无需修改版本号；
- 如果修改了非瞬态变量，则可能导致反序列化失败。**如果新类中实例变量的类型与序列化时类的类型不一致，则会反序列化失败，这时候需要更改serialVersionUID。**如果只是新增了实例变量，则反序列化回来新增的是默认值；如果减少了实例变量，反序列化时会忽略掉减少的实例变量。

### 四、总结

1. 所有需要网络传输的对象都需要实现序列化接口，通过建议所有的 javaBean 都实现 Serializable 接口。
2. 对象的类名、实例变量（包括基本类型，数组，对其他对象的引用）都会被序列化；方法、类变量、`transient` 实例变量都不会被序列化。
3. 如果想让某个变量不被序列化，使用 `transient` 修饰。
4. 序列化对象的引用类型成员变量，也必须是可序列化的，否则，会报错。
5. 反序列化时必须有序列化对象的class文件。
6. 当通过文件、网络来读取序列化后的对象时，必须按照实际写入的顺序读取。
7. 单例类序列化，需要重写`readResolve()`方法；否则会破坏单例原则。
8. 同一对象序列化多次，只有第一次序列化为二进制流，以后都只是保存序列化编号，不会重复序列化。
9. 建议所有可序列化的类加上 `serialVersionUID` 版本号，方便项目升级。

  

















