特点： 
一、从概念方面来说  

基本数据类型:变量名指向具体的数值  
引用数据类型:变量名指向存数据对象的内存地址,即变量名指向hash值  

二、从内存构建方面来说  

基本数据类型:变量在声明之后java就会立刻分配给他内存空间  

引用数据类型:它以特殊的方式(类似C指针)指向对象实体（具体的值），这类变量声明时不会分配内存，只是存储了一个内存地址。  

三、从使用方面来说  

基本数据类型:使用时需要赋具体值,判断时使用“==”号  

引用数据类型:使用时可以赋null,判断时使用equals方法  




A a; 即是声明，创建了一个A类型的变量a  

new A(); 即是实例化，实实在在地在内存里为A()划分了一块内存空间  

a=new A();即是使a指向new A()。  
以后只要你不更改a的引用，对a的任何操作都会影响到你分配出来的这块内存空间。  


理解了这个再回到问题 public class A{}   这个是对类的一个定义，此时，A只是一个“概念”，在电脑里并没有实体存在，但是java的虚拟机（jvm）已经得知了该类的所有定义，就是说，该类被加载进jvm的类加载器（class loader）了，其他的类有可能访问到该A类。 此时A本身就是jvm中的一个类，它自己当然是和自己同包，对不对？ 所以A必然可以访问到A 那么public class A{ A a=new A();} 这句话，编译期是正确的，不存在错误，所以可以声明也（被jvm认为）可以实例化。 但是到了运行期，真正的跑起来的时候，它是错误的 因为这是个迭代的死循环。 在new A()的时候，又会执行一遍A a= new A(); 然后该new A()又执行一遍A a= new A(); 如此往复，直到堆栈溢出。 当然 以下写法是正确的 public class A{ A a=null; } 嗯，事实上，有些专门的写法，如单例，工厂类，就是需要在某个类里面实例化它本身。


基本类型参数传递：传值调用  
把实参的值复制给形参，实际操作的是形参，对原值不影响

引用类型参数传递：引用调用  
传地址，影响原对象的值  
把实参的地址复制给形参，则两者指向同一个对象，无论怎么操作，都不会改变实参对该对象的引用，但会改变实参对象的内容。
