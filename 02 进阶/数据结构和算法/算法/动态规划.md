### 解题框架

**动态规划问题一般形式都是求最值**。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用的比较多。求解动态规的**核心问题是穷举**。

存在【**重叠子问题**】，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。

一定会**具备【最优子结构】**，才能通过子问题的最值得到原问题的最值。

只有列出**正确的【状态转移方程】**，才能正确地穷举。

### 例题

#### LeetCode [322] 零钱兑换

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        Integer[] memo = new Integer[amount + 1];
        int count = getCount(coins, amount, memo);
        return count;
    }

    public int getCount(int[] coins, int amount, Integer[] memo) {

        if (amount == 0) {
            return 0;
        }
        if (amount < 0) {
            return -1;
        }

        if (memo[amount] != null) {
            return memo[amount];
        }

        int res = Integer.MAX_VALUE;
        for (int coin : coins) {
            int subproblem = getCount(coins, amount - coin, memo);
            if (subproblem == -1) {
                continue;
            }
            res = Integer.min(res, subproblem + 1);
        }
        if (res == Integer.MAX_VALUE) {
            res = -1;
        }

        memo[amount] = res;
        return res;
    }

}
```

#### [70]爬楼梯





#### [120]三角形最小路径和

